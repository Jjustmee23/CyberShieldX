/**
 * Malware scanner module for CyberShieldX agent
 * Provides functionality for scanning systems for malware
 */

const { promisify } = require('util');
const exec = promisify(require('child_process').exec);
const fs = require('fs').promises;
const path = require('path');
const os = require('os');
const winston = require('winston');
const si = require('systeminformation');

// Platform detection
const isWindows = process.platform === 'win32';
const isMac = process.platform === 'darwin';
const isLinux = process.platform === 'linux';

// Setup logging
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'malware-scanner-error.log', level: 'error' }),
    new winston.transports.File({ filename: 'malware-scanner.log' }),
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    })
  ]
});

/**
 * Run a quick malware scan
 * @returns {Object} Malware scan results
 */
async function quickScan() {
  try {
    logger.info('Starting quick malware scan');
    
    // Get running processes
    const processes = await si.processes();
    
    // Check for suspicious processes
    const suspiciousProcesses = await checkSuspiciousProcesses(processes);
    
    // Check for startup items
    const startupItems = await checkStartupItems();
    
    // Check for common malware paths
    const knownMalwarePaths = await scanCommonMalwarePaths();
    
    // Check for unusual network connections
    const suspiciousConnections = await checkSuspiciousConnections();
    
    // Count findings
    const findings = {
      suspiciousProcesses: suspiciousProcesses.length,
      suspiciousStartupItems: startupItems.suspicious.length,
      possibleMalwareFound: knownMalwarePaths.malwareFound.length,
      suspiciousConnections: suspiciousConnections.length
    };
    
    return {
      timestamp: new Date().toISOString(),
      scanType: 'quick',
      findings,
      suspiciousProcesses,
      startupItems: startupItems.suspicious,
      malwareFound: knownMalwarePaths.malwareFound,
      suspiciousConnections,
      recommendations: generateRecommendations(
        suspiciousProcesses, 
        startupItems.suspicious, 
        knownMalwarePaths.malwareFound,
        suspiciousConnections
      )
    };
  } catch (error) {
    logger.error(`Quick malware scan failed: ${error.message}`);
    return {
      timestamp: new Date().toISOString(),
      scanType: 'quick',
      error: error.message,
      findings: {
        suspiciousProcesses: 0,
        suspiciousStartupItems: 0,
        possibleMalwareFound: 0,
        suspiciousConnections: 0
      }
    };
  }
}

/**
 * Run a full malware scan
 * @returns {Object} Malware scan results
 */
async function fullScan() {
  try {
    logger.info('Starting full malware scan');
    
    // Run the quick scan first
    const quickResults = await quickScan();
    
    // Additional scans for full scan
    
    // Check for rootkits
    const rootkitScan = await scanForRootkits();
    
    // Scan common data directories
    const dataDirScan = await scanDataDirectories();
    
    // Check for unusual system modifications
    const systemModifications = await checkSystemModifications();
    
    // Check for browser extensions
    const browserExtensions = await scanBrowserExtensions();
    
    // Add the extra findings to the quick scan results
    const fullResults = {
      ...quickResults,
      scanType: 'full',
      rootkits: rootkitScan.detected,
      dataDirMalware: dataDirScan.malwareFound,
      systemModifications: systemModifications.suspicious,
      suspiciousBrowserExtensions: browserExtensions.suspicious
    };
    
    // Update the findings count
    fullResults.findings = {
      ...quickResults.findings,
      rootkits: rootkitScan.detected.length,
      dataDirMalware: dataDirScan.malwareFound.length,
      systemModifications: systemModifications.suspicious.length,
      suspiciousBrowserExtensions: browserExtensions.suspicious.length
    };
    
    // Add recommendations for the additional scans
    fullResults.recommendations = [
      ...quickResults.recommendations,
      ...generateRootkitRecommendations(rootkitScan.detected),
      ...generateDataDirRecommendations(dataDirScan.malwareFound),
      ...generateSystemModificationRecommendations(systemModifications.suspicious),
      ...generateBrowserExtensionRecommendations(browserExtensions.suspicious)
    ];
    
    return fullResults;
  } catch (error) {
    logger.error(`Full malware scan failed: ${error.message}`);
    return {
      timestamp: new Date().toISOString(),
      scanType: 'full',
      error: error.message,
      findings: {
        suspiciousProcesses: 0,
        suspiciousStartupItems: 0,
        possibleMalwareFound: 0,
        suspiciousConnections: 0,
        rootkits: 0,
        dataDirMalware: 0,
        systemModifications: 0,
        suspiciousBrowserExtensions: 0
      }
    };
  }
}

/**
 * Check for suspicious running processes
 */
async function checkSuspiciousProcesses(processes) {
  const suspiciousProcesses = [];
  
  try {
    // Known suspicious process names
    const knownSuspiciousNames = [
      'cryptominer', 'miner', 'xmrig', 'btcminer', 'bitcoin',
      'backdoor', 'trojan', 'keylogger', 'spyware',
      'winnti', 'remcos', 'mimikatz', 'cobalt', 'metasploit',
      'netcat', 'nc.exe', 'psexec', 'powershell.exe'
    ];
    
    // Check running processes
    processes.list.forEach(process => {
      // Check if process name matches known suspicious names
      const processName = process.name.toLowerCase();
      
      const isSuspicious = knownSuspiciousNames.some(suspiciousName => 
        processName.includes(suspiciousName)
      );
      
      // Check for high CPU usage with unusual names
      const highCpuUsage = process.cpu > 80;
      const hasUnusualName = /^[a-z0-9]{16,}$/i.test(processName) || 
                              /^[a-z]{1,2}[0-9]{1,2}$/i.test(processName);
      
      if (isSuspicious || (highCpuUsage && hasUnusualName)) {
        suspiciousProcesses.push({
          pid: process.pid,
          name: process.name,
          cpu: process.cpu,
          mem: process.mem,
          user: process.user,
          reason: isSuspicious ? 'Known suspicious name' : 'High CPU with unusual name',
          command: process.command || ''
        });
      }
    });
  } catch (error) {
    logger.error(`Failed to check suspicious processes: ${error.message}`);
  }
  
  return suspiciousProcesses;
}

/**
 * Check startup items for suspicious entries
 */
async function checkStartupItems() {
  const allStartupItems = [];
  const suspiciousItems = [];
  
  try {
    if (isWindows) {
      // Windows startup locations
      const startupLocations = [
        '%APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup',
        '%ProgramData%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup',
        'HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run',
        'HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run',
        'HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce',
        'HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce'
      ];
      
      // Get startup items from registry
      try {
        const { stdout: runKeyOutput } = await exec('reg query "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run"');
        const runKeyItems = parseWindowsRegOutput(runKeyOutput, 'HKLM\\Run');
        allStartupItems.push(...runKeyItems);
        
        const { stdout: runUserKeyOutput } = await exec('reg query "HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run"');
        const runUserKeyItems = parseWindowsRegOutput(runUserKeyOutput, 'HKCU\\Run');
        allStartupItems.push(...runUserKeyItems);
      } catch (e) {
        logger.error(`Failed to get registry startup items: ${e.message}`);
      }
      
      // Get startup folder items
      try {
        const appDataStartupPath = process.env.APPDATA + '\\Microsoft\\Windows\\Start Menu\\Programs\\Startup';
        const files = await fs.readdir(appDataStartupPath);
        
        for (const file of files) {
          allStartupItems.push({
            name: file,
            path: path.join(appDataStartupPath, file),
            location: 'User Startup Folder'
          });
        }
      } catch (e) {
        // Startup folder might not exist or be accessible
        logger.debug(`Failed to read startup folder: ${e.message}`);
      }
    } else if (isMac) {
      // macOS startup locations
      try {
        // Check Login Items
        const { stdout: loginItemsOutput } = await exec('osascript -e \'tell application "System Events" to get the name of every login item\'');
        
        loginItemsOutput.split(', ').forEach(item => {
          if (item.trim()) {
            allStartupItems.push({
              name: item.trim(),
              location: 'Login Items'
            });
          }
        });
        
        // Check Launch Agents
        const userLaunchAgentsPath = path.join(os.homedir(), 'Library/LaunchAgents');
        const systemLaunchAgentsPath = '/Library/LaunchAgents';
        
        try {
          const userAgents = await fs.readdir(userLaunchAgentsPath);
          for (const agent of userAgents) {
            allStartupItems.push({
              name: agent,
              path: path.join(userLaunchAgentsPath, agent),
              location: 'User Launch Agents'
            });
          }
        } catch (e) {
          logger.debug(`Failed to read user launch agents: ${e.message}`);
        }
        
        try {
          const systemAgents = await fs.readdir(systemLaunchAgentsPath);
          for (const agent of systemAgents) {
            allStartupItems.push({
              name: agent,
              path: path.join(systemLaunchAgentsPath, agent),
              location: 'System Launch Agents'
            });
          }
        } catch (e) {
          logger.debug(`Failed to read system launch agents: ${e.message}`);
        }
      } catch (e) {
        logger.error(`Failed to get macOS startup items: ${e.message}`);
      }
    } else if (isLinux) {
      // Linux startup locations
      try {
        // Check systemd user services
        const userSystemdPath = path.join(os.homedir(), '.config/systemd/user');
        
        try {
          const userServices = await fs.readdir(userSystemdPath);
          for (const service of userServices) {
            if (service.endsWith('.service')) {
              allStartupItems.push({
                name: service,
                path: path.join(userSystemdPath, service),
                location: 'Systemd User Services'
              });
            }
          }
        } catch (e) {
          logger.debug(`Failed to read user systemd services: ${e.message}`);
        }
        
        // Check .profile, .bashrc, etc.
        const shellStartupFiles = [
          '.profile',
          '.bashrc',
          '.bash_profile',
          '.zshrc'
        ];
        
        for (const file of shellStartupFiles) {
          const filePath = path.join(os.homedir(), file);
          try {
            const content = await fs.readFile(filePath, 'utf8');
            // Just check if the file exists and add it to our list
            allStartupItems.push({
              name: file,
              path: filePath,
              location: 'Shell Startup Files'
            });
          } catch (e) {
            // File doesn't exist or can't be read
          }
        }
        
        // Check for cron jobs
        try {
          const { stdout: cronOutput } = await exec('crontab -l 2>/dev/null || echo ""');
          
          if (cronOutput.trim()) {
            allStartupItems.push({
              name: 'User Crontab',
              content: cronOutput.trim(),
              location: 'Cron Jobs'
            });
          }
        } catch (e) {
          logger.debug(`Failed to read crontab: ${e.message}`);
        }
      } catch (e) {
        logger.error(`Failed to get Linux startup items: ${e.message}`);
      }
    }
    
    // Check for suspicious startup items
    for (const item of allStartupItems) {
      const itemName = item.name.toLowerCase();
      const itemPath = (item.path || '').toLowerCase();
      const itemContent = (item.content || '').toLowerCase();
      
      // Check for suspicious names
      const suspiciousNames = [
        'backdoor', 'trojan', 'keylogger', 'spyware', 'miner',
        'hack', 'crack', 'steal', 'ransom', 'encrypt',
        'watchdog', 'monitor', 'spy', 'track', 'inject',
        'remote', 'access', 'control', 'hidden', 'stealth'
      ];
      
      const isSuspiciousName = suspiciousNames.some(name => 
        itemName.includes(name) || itemPath.includes(name) || itemContent.includes(name)
      );
      
      // Check for unusual paths
      const unusualPaths = [
        'temp', 'tmp', 'appdata\\local\\temp',
        'public', 'perflogs', 'inetpub',
        '/tmp', '/var/tmp', '/dev/shm'
      ];
      
      const hasUnusualPath = unusualPaths.some(path => 
        itemPath.includes(path)
      );
      
      // Check for unusual patterns
      const hasUnusualPattern = 
        /^[a-z0-9]{16,}$/i.test(itemName) || 
        /^[a-z]{1,2}[0-9]{1,2}$/i.test(itemName) ||
        itemName.includes('%temp%') ||
        itemPath.includes('powershell -enc') ||
        itemPath.includes('cmd.exe /c') ||
        itemContent.includes('curl | bash') ||
        itemContent.includes('wget | bash');
      
      if (isSuspiciousName || hasUnusualPath || hasUnusualPattern) {
        suspiciousItems.push({
          ...item,
          reason: isSuspiciousName ? 'Suspicious name' : 
                 hasUnusualPath ? 'Unusual path' : 
                 'Unusual pattern'
        });
      }
    }
  } catch (error) {
    logger.error(`Failed to check startup items: ${error.message}`);
  }
  
  return {
    all: allStartupItems,
    suspicious: suspiciousItems
  };
}

/**
 * Helper to parse Windows registry output
 */
function parseWindowsRegOutput(output, location) {
  const items = [];
  const lines = output.split('\n');
  
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim();
    if (line) {
      const parts = line.split('    ').filter(Boolean);
      if (parts.length >= 3) {
        items.push({
          name: parts[0],
          path: parts[2],
          location
        });
      }
    }
  }
  
  return items;
}

/**
 * Scan common locations for known malware
 */
async function scanCommonMalwarePaths() {
  const malwareFound = [];
  const scannedLocations = [];
  
  try {
    // Define common malware paths based on OS
    let locationsToScan = [];
    
    if (isWindows) {
      locationsToScan = [
        path.join(os.tmpdir()),
        path.join(process.env.APPDATA, 'Temp'),
        path.join(process.env.APPDATA, 'Microsoft', 'Windows', 'Recent'),
        path.join(process.env.LOCALAPPDATA, 'Temp'),
        path.join(process.env.SYSTEMROOT, 'Temp')
      ];
    } else if (isMac) {
      locationsToScan = [
        '/tmp',
        path.join(os.homedir(), 'Library/Caches'),
        path.join(os.homedir(), 'Library/Application Support'),
        path.join(os.homedir(), 'Downloads')
      ];
    } else if (isLinux) {
      locationsToScan = [
        '/tmp',
        '/var/tmp',
        '/dev/shm',
        path.join(os.homedir(), 'Downloads'),
        path.join(os.homedir(), '.cache')
      ];
    }
    
    // Known malicious file patterns
    const maliciousPatterns = [
      // Executable files with suspicious names
      /ransomware.*\.(exe|bin)$/i,
      /trojan.*\.(exe|bin)$/i,
      /keylogger.*\.(exe|bin)$/i,
      /backdoor.*\.(exe|bin)$/i,
      /miner.*\.(exe|bin)$/i,
      
      // Scripts with suspicious names
      /hack.*\.(bat|sh|ps1|vbs)$/i,
      /steal.*\.(bat|sh|ps1|vbs)$/i,
      /spy.*\.(bat|sh|ps1|vbs)$/i,
      
      // Hidden executables
      /^\..+\.(exe|bin)$/i,
      
      // Suspicious patterns (pseudo-randoms or very long names)
      /^[a-z0-9]{20,}\.(exe|bin|sh|bat)$/i
    ];
    
    // Scan each location
    for (const location of locationsToScan) {
      try {
        scannedLocations.push(location);
        const files = await fs.readdir(location);
        
        for (const file of files) {
          const filePath = path.join(location, file);
          const isMalicious = maliciousPatterns.some(pattern => pattern.test(file));
          
          if (isMalicious) {
            try {
              const stats = await fs.stat(filePath);
              
              malwareFound.push({
                name: file,
                path: filePath,
                size: stats.size,
                created: stats.birthtime,
                modified: stats.mtime,
                reason: 'Matches malicious pattern'
              });
            } catch (e) {
              // Can't stat the file
              malwareFound.push({
                name: file,
                path: filePath,
                reason: 'Matches malicious pattern (could not get file stats)'
              });
            }
          }
        }
      } catch (e) {
        logger.debug(`Could not scan location ${location}: ${e.message}`);
      }
    }
  } catch (error) {
    logger.error(`Failed to scan common malware paths: ${error.message}`);
  }
  
  return {
    malwareFound,
    scannedLocations
  };
}

/**
 * Check for suspicious network connections
 */
async function checkSuspiciousConnections() {
  const suspiciousConnections = [];
  
  try {
    // Get network connections
    const connections = await si.networkConnections();
    
    // Known suspicious ports
    const suspiciousPorts = [
      // Common backdoor ports
      4444, 1337, 31337, 6666, 6667, 6668, 6669,
      // Uncommon but often used for malicious purposes
      8080, 8888, 9999, 6000, 1024, 1025, 1026, 1027, 1028, 1029, 1030
    ];
    
    // Known suspicious remote addresses
    const suspiciousIPs = [
      // Tor exit nodes might have these patterns (simplified for example)
      /^176\.10\./, /^193\.11\./, /^31\.13\./, /^104\.149\./,
      // Common mining pools
      /xmr-pool/, /monero-pool/, /cryptonight/,
      // Suspicious domains
      /\.onion$/, /\.top$/, /\.xyz$/, /\.cc$/
    ];
    
    // Check each connection
    connections.forEach(conn => {
      // Skip local connections
      if (conn.localaddress === '127.0.0.1' || conn.localaddress === '::1') {
        return;
      }
      
      let isSuspicious = false;
      let reason = '';
      
      // Check for known suspicious ports
      if (suspiciousPorts.includes(conn.remoteport)) {
        isSuspicious = true;
        reason = `Connection to suspicious port: ${conn.remoteport}`;
      }
      
      // Check for suspicious IPs or domains
      if (!isSuspicious && conn.remoteaddress) {
        for (const pattern of suspiciousIPs) {
          if (pattern.test(conn.remoteaddress)) {
            isSuspicious = true;
            reason = `Connection to suspicious address: ${conn.remoteaddress}`;
            break;
          }
        }
      }
      
      // Add to list if suspicious
      if (isSuspicious) {
        suspiciousConnections.push({
          pid: conn.pid,
          protocol: conn.protocol,
          localAddress: conn.localaddress,
          localPort: conn.localport,
          remoteAddress: conn.remoteaddress,
          remotePort: conn.remoteport,
          state: conn.state,
          reason
        });
      }
    });
  } catch (error) {
    logger.error(`Failed to check suspicious connections: ${error.message}`);
  }
  
  return suspiciousConnections;
}

/**
 * Scan for rootkits (full scan only)
 */
async function scanForRootkits() {
  const detected = [];
  
  try {
    // A real rootkit scanner would use specialized tools
    // Here we'll simulate some basic checks
    
    if (isWindows) {
      // Check for hidden processes (simplified)
      try {
        // Get process list from two different sources and compare
        const { stdout: tasklist } = await exec('tasklist /FO CSV');
        const { stdout: wmic } = await exec('wmic process get processid,name');
        
        // This is a simplified check - in reality we'd parse and compare properly
        if (tasklist.length / wmic.length < 0.7) {
          detected.push({
            type: 'Process hiding',
            description: 'Possible process hiding detected by comparing process lists from different sources',
            severity: 'high'
          });
        }
      } catch (e) {
        logger.error(`Failed to check for hidden processes: ${e.message}`);
      }
    } else if (isLinux) {
      // Check for LKM rootkits (very simplified)
      try {
        const { stdout: lsmod } = await exec('lsmod');
        const { stdout: procModules } = await exec('cat /proc/modules');
        
        // This is a simplified check - in reality we'd parse and compare properly
        if (lsmod.length / procModules.length < 0.7) {
          detected.push({
            type: 'Kernel module hiding',
            description: 'Possible kernel module hiding detected by comparing module lists from different sources',
            severity: 'high'
          });
        }
      } catch (e) {
        logger.error(`Failed to check for hidden kernel modules: ${e.message}`);
      }
    }
    
    // Check for common rootkit files (all platforms)
    const rootkitFiles = isWindows ? [
      'C:\\Windows\\System32\\drivers\\rootkit.sys',
      'C:\\Windows\\System32\\beep.sys',
      'C:\\Windows\\SysWOW64\\drivers\\sst.sys'
    ] : [
      '/dev/.hdparm',
      '/dev/.udev',
      '/lib/modules/`.uname -r`/kernel/drivers/sound/.snd',
      '/usr/lib/`.uname -r`/.snd',
      '/tmp/.ICE-unix/.tmp',
      '/usr/share/.local',
      '/usr/share/.sst'
    ];
    
    for (const file of rootkitFiles) {
      try {
        await fs.access(file);
        // If we get here, the file exists, which is suspicious
        detected.push({
          type: 'Suspicious file',
          description: `Found potential rootkit file: ${file}`,
          path: file,
          severity: 'high'
        });
      } catch (e) {
        // File doesn't exist, which is good
      }
    }
  } catch (error) {
    logger.error(`Failed to scan for rootkits: ${error.message}`);
  }
  
  return {
    detected
  };
}

/**
 * Scan common data directories for malware (full scan only)
 */
async function scanDataDirectories() {
  const scannedLocations = [];
  const malwareFound = [];
  
  try {
    // Additional common directories to scan for malware
    let locationsToScan = [];
    
    if (isWindows) {
      locationsToScan = [
        path.join(process.env.USERPROFILE, 'Documents'),
        path.join(process.env.USERPROFILE, 'Downloads'),
        path.join(process.env.PROGRAMDATA, 'Microsoft', 'Windows'),
        path.join(process.env.APPDATA, 'Microsoft', 'Internet Explorer'),
        path.join(process.env.LOCALAPPDATA, 'Google', 'Chrome', 'User Data', 'Default'),
        path.join(process.env.APPDATA, 'Mozilla', 'Firefox', 'Profiles')
      ];
    } else if (isMac) {
      locationsToScan = [
        path.join(os.homedir(), 'Documents'),
        path.join(os.homedir(), 'Library', 'Application Support', 'Google', 'Chrome'),
        path.join(os.homedir(), 'Library', 'Application Support', 'Firefox'),
        '/Library/LaunchDaemons',
        '/Library/LaunchAgents'
      ];
    } else if (isLinux) {
      locationsToScan = [
        path.join(os.homedir(), 'Documents'),
        path.join(os.homedir(), '.mozilla'),
        path.join(os.homedir(), '.config', 'google-chrome'),
        '/etc/cron.d',
        '/etc/init.d'
      ];
    }
    
    // Known malicious file patterns (more thorough than quick scan)
    const maliciousPatterns = [
      // Executable files with suspicious names
      /(ransomware|trojan|keylogger|backdoor|miner|exploit|hack|steal|spy)/i,
      
      // Uncommon file extensions in normal directories
      /\.(ps1|bat|vbs|hta|jse|wsh)$/i,
      
      // Files with double extensions (common malware tactic)
      /\.(jpeg|png|gif|pdf|doc|docx|xls|xlsx|txt|rtf)\.(exe|bat|vbs|js|ps1|cmd)$/i,
      
      // Hidden executables or scripts
      /^\..+\.(exe|bin|sh|bat|ps1|py|php|pl)$/i
    ];
    
    // Scan each location
    for (const location of locationsToScan) {
      try {
        scannedLocations.push(location);
        await scanDirectory(location, maliciousPatterns, malwareFound);
      } catch (e) {
        logger.debug(`Could not scan location ${location}: ${e.message}`);
      }
    }
  } catch (error) {
    logger.error(`Failed to scan data directories: ${error.message}`);
  }
  
  return {
    malwareFound,
    scannedLocations
  };
}

/**
 * Helper to recursively scan a directory
 */
async function scanDirectory(directory, patterns, results, depth = 0) {
  // Limit recursion depth to avoid scanning too many directories
  if (depth > 3) return;
  
  try {
    const files = await fs.readdir(directory);
    
    for (const file of files) {
      const filePath = path.join(directory, file);
      
      try {
        const stats = await fs.stat(filePath);
        
        if (stats.isDirectory()) {
          // Recursively scan subdirectories
          await scanDirectory(filePath, patterns, results, depth + 1);
        } else {
          // Check the file against patterns
          const isMalicious = patterns.some(pattern => pattern.test(file));
          
          if (isMalicious) {
            results.push({
              name: file,
              path: filePath,
              size: stats.size,
              created: stats.birthtime,
              modified: stats.mtime,
              reason: 'Matches malicious pattern'
            });
          }
        }
      } catch (e) {
        // Couldn't access this file or directory, log and continue
        logger.debug(`Could not access ${filePath}: ${e.message}`);
      }
    }
  } catch (e) {
    logger.debug(`Error scanning directory ${directory}: ${e.message}`);
  }
}

/**
 * Check for unusual system modifications (full scan only)
 */
async function checkSystemModifications() {
  const suspicious = [];
  
  try {
    if (isWindows) {
      // Check for hosts file modifications
      try {
        const hostsPath = 'C:\\Windows\\System32\\drivers\\etc\\hosts';
        const content = await fs.readFile(hostsPath, 'utf8');
        
        // Check for unusual entries
        const lines = content.split('\n');
        for (const line of lines) {
          // Skip comments and empty lines
          if (line.trim().startsWith('#') || line.trim() === '') continue;
          
          // Check for suspicious redirects
          if (line.includes('google.com') || 
              line.includes('microsoft.com') || 
              line.includes('windowsupdate.com') || 
              line.includes('facebook.com') || 
              line.includes('antivirus')) {
            suspicious.push({
              type: 'Hosts file modification',
              description: `Suspicious hosts file entry: ${line.trim()}`,
              severity: 'medium'
            });
          }
        }
      } catch (e) {
        logger.debug(`Could not check hosts file: ${e.message}`);
      }
      
      // Check for unusual DLL injection
      try {
        const { stdout } = await exec('reg query "HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows" /v AppInit_DLLs');
        
        if (!stdout.includes('AppInit_DLLs    REG_SZ') || !stdout.includes('(value not set)')) {
          suspicious.push({
            type: 'AppInit_DLLs modification',
            description: 'System set to load custom DLLs into processes, which could be malicious',
            severity: 'high'
          });
        }
      } catch (e) {
        logger.debug(`Could not check AppInit_DLLs: ${e.message}`);
      }
    } else if (isMac || isLinux) {
      // Check for hosts file modifications
      try {
        const hostsPath = '/etc/hosts';
        const content = await fs.readFile(hostsPath, 'utf8');
        
        // Check for unusual entries
        const lines = content.split('\n');
        for (const line of lines) {
          // Skip comments and empty lines
          if (line.trim().startsWith('#') || line.trim() === '') continue;
          
          // Check for suspicious redirects
          if (line.includes('google.com') || 
              line.includes('apple.com') || 
              line.includes('microsoft.com') || 
              line.includes('facebook.com') || 
              line.includes('antivirus')) {
            suspicious.push({
              type: 'Hosts file modification',
              description: `Suspicious hosts file entry: ${line.trim()}`,
              severity: 'medium'
            });
          }
        }
      } catch (e) {
        logger.debug(`Could not check hosts file: ${e.message}`);
      }
      
      if (isLinux) {
        // Check for unusual SUID binaries
        try {
          const { stdout } = await exec('find /usr /bin /sbin /opt -perm -4000 2>/dev/null');
          
          const knownSuidBinaries = [
            '/usr/bin/sudo',
            '/usr/bin/passwd',
            '/usr/bin/su',
            '/usr/bin/ping',
            '/bin/su',
            '/bin/ping',
            '/sbin/unix_chkpwd'
          ];
          
          const lines = stdout.split('\n');
          for (const line of lines) {
            if (line.trim() && !knownSuidBinaries.includes(line.trim())) {
              suspicious.push({
                type: 'Unusual SUID binary',
                description: `Unusual SUID binary found: ${line.trim()}`,
                severity: 'high'
              });
            }
          }
        } catch (e) {
          logger.debug(`Could not check SUID binaries: ${e.message}`);
        }
      }
    }
  } catch (error) {
    logger.error(`Failed to check system modifications: ${error.message}`);
  }
  
  return { 
    suspicious 
  };
}

/**
 * Scan browser extensions for suspicious items (full scan only)
 */
async function scanBrowserExtensions() {
  const suspicious = [];
  
  try {
    // Get browser extension directories
    let extensionDirs = [];
    
    if (isWindows) {
      // Chrome
      extensionDirs.push(
        path.join(process.env.LOCALAPPDATA, 'Google', 'Chrome', 'User Data', 'Default', 'Extensions'),
        path.join(process.env.LOCALAPPDATA, 'Google', 'Chrome', 'User Data', 'Profile 1', 'Extensions')
      );
      
      // Firefox
      const firefoxDir = path.join(process.env.APPDATA, 'Mozilla', 'Firefox', 'Profiles');
      try {
        const profiles = await fs.readdir(firefoxDir);
        for (const profile of profiles) {
          extensionDirs.push(path.join(firefoxDir, profile, 'extensions'));
        }
      } catch (e) {
        logger.debug(`Could not scan Firefox extensions: ${e.message}`);
      }
    } else if (isMac) {
      // Chrome
      extensionDirs.push(
        path.join(os.homedir(), 'Library', 'Application Support', 'Google', 'Chrome', 'Default', 'Extensions'),
        path.join(os.homedir(), 'Library', 'Application Support', 'Google', 'Chrome', 'Profile 1', 'Extensions')
      );
      
      // Firefox
      const firefoxDir = path.join(os.homedir(), 'Library', 'Application Support', 'Firefox', 'Profiles');
      try {
        const profiles = await fs.readdir(firefoxDir);
        for (const profile of profiles) {
          extensionDirs.push(path.join(firefoxDir, profile, 'extensions'));
        }
      } catch (e) {
        logger.debug(`Could not scan Firefox extensions: ${e.message}`);
      }
    } else if (isLinux) {
      // Chrome
      extensionDirs.push(
        path.join(os.homedir(), '.config', 'google-chrome', 'Default', 'Extensions'),
        path.join(os.homedir(), '.config', 'google-chrome', 'Profile 1', 'Extensions')
      );
      
      // Firefox
      const firefoxDir = path.join(os.homedir(), '.mozilla', 'firefox');
      try {
        const profiles = await fs.readdir(firefoxDir);
        for (const profile of profiles) {
          if (profile.includes('default')) {
            extensionDirs.push(path.join(firefoxDir, profile, 'extensions'));
          }
        }
      } catch (e) {
        logger.debug(`Could not scan Firefox extensions: ${e.message}`);
      }
    }
    
    // Scan each extension directory
    for (const dir of extensionDirs) {
      try {
        const extensions = await fs.readdir(dir);
        
        for (const extension of extensions) {
          // Try to read the manifest
          try {
            let manifestPath;
            
            if (dir.includes('Chrome')) {
              // Chrome extension structure is complex
              const versions = await fs.readdir(path.join(dir, extension));
              const latestVersion = versions.sort().pop();
              manifestPath = path.join(dir, extension, latestVersion, 'manifest.json');
            } else {
              // Firefox has simpler structure
              manifestPath = path.join(dir, extension, 'manifest.json');
            }
            
            const manifest = JSON.parse(await fs.readFile(manifestPath, 'utf8'));
            
            // Check permissions
            const highRiskPermissions = [
              'tabs', 'webRequest', 'webRequestBlocking', 'proxy',
              '<all_urls>', '*://*/*', 'bookmarks', 'history',
              'management', 'privacy', 'cookies'
            ];
            
            const hasHighRiskPerms = manifest.permissions && 
              manifest.permissions.some(perm => 
                highRiskPermissions.includes(perm) || perm.includes('*')
              );
            
            // Check if extension was installed from the store
            const notFromStore = !manifest.update_url || 
              !manifest.update_url.includes('chrome.google.com') || 
              !manifest.update_url.includes('addons.mozilla.org');
            
            if (hasHighRiskPerms && notFromStore) {
              suspicious.push({
                name: manifest.name || extension,
                id: extension,
                browser: dir.includes('Chrome') ? 'Chrome' : 'Firefox',
                permissions: manifest.permissions || [],
                reason: 'High-risk permissions and not from official store',
                severity: 'high'
              });
            } else if (hasHighRiskPerms) {
              suspicious.push({
                name: manifest.name || extension,
                id: extension,
                browser: dir.includes('Chrome') ? 'Chrome' : 'Firefox',
                permissions: manifest.permissions || [],
                reason: 'High-risk permissions',
                severity: 'medium'
              });
            } else if (notFromStore) {
              suspicious.push({
                name: manifest.name || extension,
                id: extension,
                browser: dir.includes('Chrome') ? 'Chrome' : 'Firefox',
                permissions: manifest.permissions || [],
                reason: 'Not from official store',
                severity: 'low'
              });
            }
          } catch (e) {
            logger.debug(`Could not read manifest for ${extension}: ${e.message}`);
          }
        }
      } catch (e) {
        logger.debug(`Could not scan extension directory ${dir}: ${e.message}`);
      }
    }
  } catch (error) {
    logger.error(`Failed to scan browser extensions: ${error.message}`);
  }
  
  return { 
    suspicious 
  };
}

/**
 * Generate recommendations based on malware findings
 */
function generateRecommendations(
  suspiciousProcesses, 
  suspiciousStartupItems, 
  malwareFound,
  suspiciousConnections
) {
  const recommendations = [];
  
  // Process recommendations
  if (suspiciousProcesses.length > 0) {
    recommendations.push({
      priority: 'high',
      recommendation: 'Investigate and terminate suspicious processes',
      details: 'Use Task Manager (Windows) or Activity Monitor (Mac) to terminate the suspicious processes and investigate their source.'
    });
    
    suspiciousProcesses.forEach(process => {
      recommendations.push({
        priority: 'medium',
        recommendation: `Investigate process: ${process.name} (PID: ${process.pid})`,
        details: `This process was flagged as suspicious because: ${process.reason}`
      });
    });
  }
  
  // Startup item recommendations
  if (suspiciousStartupItems.length > 0) {
    recommendations.push({
      priority: 'high',
      recommendation: 'Remove suspicious startup items',
      details: 'These items run automatically at system startup and may be malicious.'
    });
    
    suspiciousStartupItems.forEach(item => {
      recommendations.push({
        priority: 'medium',
        recommendation: `Remove startup item: ${item.name}`,
        details: `Located at: ${item.path || item.location}, flagged because: ${item.reason}`
      });
    });
  }
  
  // Malware file recommendations
  if (malwareFound.length > 0) {
    recommendations.push({
      priority: 'high',
      recommendation: 'Delete suspicious files',
      details: 'The following files match patterns commonly associated with malware.'
    });
    
    malwareFound.forEach(file => {
      recommendations.push({
        priority: 'medium',
        recommendation: `Delete suspicious file: ${file.name}`,
        details: `Located at: ${file.path}, flagged because: ${file.reason}`
      });
    });
  }
  
  // Network connection recommendations
  if (suspiciousConnections.length > 0) {
    recommendations.push({
      priority: 'high',
      recommendation: 'Investigate suspicious network connections',
      details: 'The following network connections may indicate command and control activity or data exfiltration.'
    });
    
    suspiciousConnections.forEach(conn => {
      recommendations.push({
        priority: 'medium',
        recommendation: `Investigate connection to ${conn.remoteAddress}:${conn.remotePort}`,
        details: `This connection was flagged because: ${conn.reason}`
      });
    });
  }
  
  // General recommendations
  if (suspiciousProcesses.length > 0 || suspiciousStartupItems.length > 0 || 
      malwareFound.length > 0 || suspiciousConnections.length > 0) {
    recommendations.push({
      priority: 'high',
      recommendation: 'Run a full system scan with antivirus software',
      details: 'Use a reputable antivirus program to perform a complete system scan.'
    });
    
    recommendations.push({
      priority: 'medium',
      recommendation: 'Update your operating system and applications',
      details: 'Ensure your system and all applications are up to date with the latest security patches.'
    });
  } else {
    recommendations.push({
      priority: 'low',
      recommendation: 'Continue good security practices',
      details: 'No suspicious items were found. Continue to maintain good security practices such as regular updates and backups.'
    });
  }
  
  return recommendations;
}

/**
 * Generate recommendations for rootkit findings
 */
function generateRootkitRecommendations(rootkitFindings) {
  const recommendations = [];
  
  if (rootkitFindings.length > 0) {
    recommendations.push({
      priority: 'critical',
      recommendation: 'System may be compromised by rootkit, consider full reinstall',
      details: 'Rootkits are extremely difficult to completely remove. In many cases, a full system reinstallation is the safest option.'
    });
    
    rootkitFindings.forEach(finding => {
      recommendations.push({
        priority: 'high',
        recommendation: `Investigate potential rootkit: ${finding.type}`,
        details: `${finding.description}. This is a ${finding.severity} severity issue.`
      });
    });
    
    recommendations.push({
      priority: 'high',
      recommendation: 'Disconnect from network immediately',
      details: 'If rootkit presence is confirmed, disconnect the system from all networks to prevent data exfiltration or lateral movement.'
    });
  }
  
  return recommendations;
}

/**
 * Generate recommendations for data directory scan findings
 */
function generateDataDirRecommendations(malwareFound) {
  const recommendations = [];
  
  if (malwareFound.length > 0) {
    recommendations.push({
      priority: 'high',
      recommendation: 'Delete suspicious files found in data directories',
      details: 'The following files match patterns commonly associated with malware.'
    });
    
    malwareFound.forEach(file => {
      recommendations.push({
        priority: 'medium',
        recommendation: `Delete suspicious file: ${file.name}`,
        details: `Located at: ${file.path}, flagged because: ${file.reason}`
      });
    });
  }
  
  return recommendations;
}

/**
 * Generate recommendations for system modification findings
 */
function generateSystemModificationRecommendations(modifications) {
  const recommendations = [];
  
  if (modifications.length > 0) {
    recommendations.push({
      priority: 'high',
      recommendation: 'Revert suspicious system modifications',
      details: 'The following system modifications may indicate a compromise.'
    });
    
    const hostsFileModifications = modifications.filter(m => m.type === 'Hosts file modification');
    if (hostsFileModifications.length > 0) {
      recommendations.push({
        priority: 'high',
        recommendation: 'Clean hosts file of suspicious entries',
        details: 'Remove the suspicious entries from your hosts file or restore it from a known good backup.'
      });
    }
    
    const suidFindings = modifications.filter(m => m.type === 'Unusual SUID binary');
    if (suidFindings.length > 0) {
      recommendations.push({
        priority: 'high',
        recommendation: 'Remove unusual SUID binaries',
        details: 'These binaries have elevated permissions and could be used for privilege escalation.'
      });
    }
    
    const dllInjection = modifications.filter(m => m.type === 'AppInit_DLLs modification');
    if (dllInjection.length > 0) {
      recommendations.push({
        priority: 'high',
        recommendation: 'Remove AppInit_DLLs modifications',
        details: 'Reset the AppInit_DLLs registry value to prevent malicious code injection.'
      });
    }
  }
  
  return recommendations;
}

/**
 * Generate recommendations for browser extension findings
 */
function generateBrowserExtensionRecommendations(suspiciousExtensions) {
  const recommendations = [];
  
  if (suspiciousExtensions.length > 0) {
    recommendations.push({
      priority: 'high',
      recommendation: 'Remove suspicious browser extensions',
      details: 'The following browser extensions have high-risk permissions or were not installed from official stores.'
    });
    
    // Group by severity
    const highSeverity = suspiciousExtensions.filter(e => e.severity === 'high');
    const mediumSeverity = suspiciousExtensions.filter(e => e.severity === 'medium');
    const lowSeverity = suspiciousExtensions.filter(e => e.severity === 'low');
    
    highSeverity.forEach(ext => {
      recommendations.push({
        priority: 'high',
        recommendation: `Remove ${ext.browser} extension: ${ext.name}`,
        details: `This extension was flagged because: ${ext.reason}`
      });
    });
    
    mediumSeverity.forEach(ext => {
      recommendations.push({
        priority: 'medium',
        recommendation: `Review permissions of ${ext.browser} extension: ${ext.name}`,
        details: `This extension has high-risk permissions: ${ext.permissions.join(', ')}`
      });
    });
    
    if (lowSeverity.length > 0) {
      recommendations.push({
        priority: 'low',
        recommendation: `Verify ${lowSeverity.length} extensions not from official stores`,
        details: 'These extensions were not installed from the official browser stores and should be verified.'
      });
    }
  }
  
  return recommendations;
}

module.exports = {
  quickScan,
  fullScan
};