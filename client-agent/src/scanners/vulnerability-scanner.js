/**
 * Vulnerability scanner module for CyberShieldX agent
 * Provides functionality for scanning systems for security vulnerabilities
 */

const { promisify } = require('util');
const exec = promisify(require('child_process').exec);
const os = require('os');
const fs = require('fs').promises;
const path = require('path');
const winston = require('winston');
const si = require('systeminformation');

// Platform detection
const isWindows = process.platform === 'win32';
const isMac = process.platform === 'darwin';
const isLinux = process.platform === 'linux';

// Setup logging
const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'vuln-scanner-error.log', level: 'error' }),
    new winston.transports.File({ filename: 'vuln-scanner.log' }),
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    })
  ]
});

/**
 * Scan the local system for vulnerabilities
 * @param {boolean} thorough - Whether to do a thorough scan
 * @returns {Object} Vulnerability scan results
 */
async function scanLocalSystem(thorough = false) {
  try {
    logger.info(`Starting local vulnerability scan (thorough: ${thorough})`);
    
    // Collect software information
    const [osInfo, services, installedSoftware] = await Promise.all([
      si.osInfo(),
      si.services('*'),
      getSoftwareVersions()
    ]);
    
    // Check for known vulnerabilities in the OS
    const osVulnerabilities = await checkOSVulnerabilities(osInfo);
    
    // Check for weak configurations
    const weakConfigs = await checkWeakConfigurations();
    
    // Check for outdated software
    const outdatedSoftware = await checkOutdatedSoftware(installedSoftware);
    
    // Check for insecure services
    const insecureServices = checkInsecureServices(services);
    
    // If thorough scan, check for more issues
    let additionalChecks = {};
    if (thorough) {
      additionalChecks = await thoroughChecks();
    }
    
    // Count vulnerabilities by severity
    const vulnerabilityCounts = {
      high: osVulnerabilities.high.length + weakConfigs.high.length + outdatedSoftware.high.length + insecureServices.high.length,
      medium: osVulnerabilities.medium.length + weakConfigs.medium.length + outdatedSoftware.medium.length + insecureServices.medium.length,
      low: osVulnerabilities.low.length + weakConfigs.low.length + outdatedSoftware.low.length + insecureServices.low.length
    };
    
    if (thorough && additionalChecks.vulnerabilityCounts) {
      vulnerabilityCounts.high += additionalChecks.vulnerabilityCounts.high || 0;
      vulnerabilityCounts.medium += additionalChecks.vulnerabilityCounts.medium || 0;
      vulnerabilityCounts.low += additionalChecks.vulnerabilityCounts.low || 0;
    }
    
    return {
      timestamp: new Date().toISOString(),
      osVulnerabilities,
      weakConfigurations: weakConfigs,
      outdatedSoftware,
      insecureServices,
      ...(thorough ? { additionalChecks } : {}),
      vulnerabilityCounts,
      recommendations: generateRecommendations(osVulnerabilities, weakConfigs, outdatedSoftware, insecureServices)
    };
  } catch (error) {
    logger.error(`Local vulnerability scan failed: ${error.message}`);
    return {
      timestamp: new Date().toISOString(),
      error: error.message,
      vulnerabilityCounts: { high: 0, medium: 0, low: 0 }
    };
  }
}

/**
 * Scan the network for vulnerabilities
 * @param {boolean} thorough - Whether to do a thorough scan
 * @returns {Object} Network vulnerability scan results
 */
async function scanNetwork(thorough = false) {
  try {
    logger.info(`Starting network vulnerability scan (thorough: ${thorough})`);
    
    // Since we don't want to implement a full vulnerability scanner,
    // we'll simulate checking for common network vulnerabilities
    
    // Check for open ports that are commonly targeted
    const openPorts = await checkCommonVulnerablePorts();
    
    // Check for weak encryption in network services
    const weakEncryption = await checkWeakEncryption();
    
    // Check for default credentials
    const defaultCredentials = await checkDefaultCredentials();
    
    // Additional checks for thorough scan
    let additionalChecks = {};
    if (thorough) {
      additionalChecks = await thoroughNetworkChecks();
    }
    
    // Count vulnerabilities by severity
    const vulnerabilityCounts = {
      high: openPorts.high.length + weakEncryption.high.length + defaultCredentials.high.length,
      medium: openPorts.medium.length + weakEncryption.medium.length + defaultCredentials.medium.length,
      low: openPorts.low.length + weakEncryption.low.length + defaultCredentials.low.length
    };
    
    if (thorough && additionalChecks.vulnerabilityCounts) {
      vulnerabilityCounts.high += additionalChecks.vulnerabilityCounts.high || 0;
      vulnerabilityCounts.medium += additionalChecks.vulnerabilityCounts.medium || 0;
      vulnerabilityCounts.low += additionalChecks.vulnerabilityCounts.low || 0;
    }
    
    return {
      timestamp: new Date().toISOString(),
      openVulnerablePorts: openPorts,
      weakEncryption,
      defaultCredentials,
      ...(thorough ? { additionalChecks } : {}),
      vulnerabilityCounts,
      recommendations: generateNetworkRecommendations(openPorts, weakEncryption, defaultCredentials)
    };
  } catch (error) {
    logger.error(`Network vulnerability scan failed: ${error.message}`);
    return {
      timestamp: new Date().toISOString(),
      error: error.message,
      vulnerabilityCounts: { high: 0, medium: 0, low: 0 }
    };
  }
}

/**
 * Get list of installed software with versions
 */
async function getSoftwareVersions() {
  const software = [];
  
  try {
    if (isWindows) {
      // Windows software
      const { stdout } = await exec('powershell -Command "Get-ItemProperty HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* | Select-Object DisplayName, DisplayVersion | ConvertTo-Json"');
      
      const parsed = JSON.parse(stdout);
      if (Array.isArray(parsed)) {
        parsed.forEach(item => {
          if (item.DisplayName) {
            software.push({
              name: item.DisplayName,
              version: item.DisplayVersion || 'Unknown'
            });
          }
        });
      } else if (parsed && parsed.DisplayName) {
        software.push({
          name: parsed.DisplayName,
          version: parsed.DisplayVersion || 'Unknown'
        });
      }
    } else if (isMac) {
      // macOS - get application listing
      const { stdout } = await exec('ls -la /Applications | grep ".app$"');
      stdout.split('\n').forEach(line => {
        if (line.trim()) {
          const appName = line.substring(line.lastIndexOf(' ') + 1).replace('.app', '');
          software.push({
            name: appName,
            version: 'Unknown' // Would need deep inspection to get versions
          });
        }
      });
    } else if (isLinux) {
      // Linux - try apt or rpm depending on distro
      try {
        let stdout;
        if (await fileExists('/usr/bin/dpkg')) {
          // Debian/Ubuntu
          const { stdout: dpkgOut } = await exec('dpkg-query -W -f=\'${Package} ${Version}\\n\'');
          stdout = dpkgOut;
        } else if (await fileExists('/usr/bin/rpm')) {
          // Red Hat/CentOS/Fedora
          const { stdout: rpmOut } = await exec('rpm -qa --queryformat "%{NAME} %{VERSION}\\n"');
          stdout = rpmOut;
        } else {
          // Try a generic approach
          const { stdout: aptOut } = await exec('apt list --installed 2>/dev/null || yum list installed 2>/dev/null');
          stdout = aptOut;
        }
        
        stdout.split('\n').forEach(line => {
          if (line.trim()) {
            const parts = line.split(' ');
            if (parts.length >= 2) {
              software.push({
                name: parts[0],
                version: parts[1]
              });
            }
          }
        });
      } catch (e) {
        logger.error(`Error getting Linux software: ${e.message}`);
      }
    }
  } catch (error) {
    logger.error(`Failed to get software versions: ${error.message}`);
  }
  
  return software;
}

/**
 * Check if a file exists
 */
async function fileExists(filePath) {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Check for known OS vulnerabilities
 */
async function checkOSVulnerabilities(osInfo) {
  const high = [];
  const medium = [];
  const low = [];
  
  try {
    if (isWindows) {
      // Check Windows versions
      if (osInfo.release === '10.0.10240' || 
          osInfo.release === '10.0.10586' || 
          osInfo.release === '10.0.14393') {
        // Old Windows 10 versions
        medium.push({
          name: 'End of Service Windows Version',
          description: `Windows 10 version ${osInfo.release} is no longer supported with security updates.`,
          recommendation: 'Upgrade to a supported version of Windows 10/11.'
        });
      } else if (osInfo.distro.includes('Windows 7') || 
                osInfo.distro.includes('Windows 8')) {
        // EOL versions
        high.push({
          name: 'Unsupported Windows Version',
          description: `${osInfo.distro} is no longer supported with security updates.`,
          recommendation: 'Upgrade to a supported version of Windows 10/11.'
        });
      }
      
      // Check for SMBv1
      try {
        const { stdout } = await exec('powershell -Command "Get-SmbServerConfiguration | Select-Object EnableSMB1Protocol"');
        if (stdout.includes('True')) {
          high.push({
            name: 'SMBv1 Protocol Enabled',
            description: 'SMBv1 is vulnerable to various attacks including WannaCry ransomware.',
            recommendation: 'Disable SMBv1 using PowerShell: Set-SmbServerConfiguration -EnableSMB1Protocol $false'
          });
        }
      } catch (e) {
        logger.error(`SMBv1 check failed: ${e.message}`);
      }
    } else if (isMac) {
      // Check macOS versions
      const majorVersion = parseInt(osInfo.release.split('.')[0]);
      const minorVersion = parseInt(osInfo.release.split('.')[1] || 0);
      
      if (majorVersion < 10 || (majorVersion === 10 && minorVersion < 15)) {
        // macOS older than Catalina
        high.push({
          name: 'Unsupported macOS Version',
          description: `macOS ${osInfo.release} is no longer receiving security updates.`,
          recommendation: 'Upgrade to a supported version of macOS.'
        });
      } else if (majorVersion === 10 && minorVersion === 15) {
        // Catalina - check if still supported
        medium.push({
          name: 'Aging macOS Version',
          description: 'macOS Catalina may not receive security updates much longer.',
          recommendation: 'Consider upgrading to a newer version of macOS.'
        });
      }
      
      // Check for SIP status
      try {
        const { stdout } = await exec('csrutil status');
        if (stdout.includes('disabled')) {
          high.push({
            name: 'System Integrity Protection Disabled',
            description: 'SIP is a key security feature of macOS that is currently disabled.',
            recommendation: 'Enable SIP by restarting in Recovery mode and running "csrutil enable"'
          });
        }
      } catch (e) {
        logger.error(`SIP check failed: ${e.message}`);
      }
    } else if (isLinux) {
      // Check Linux distribution for EOL versions
      if ((osInfo.distro.includes('Ubuntu 16.04') || 
           osInfo.distro.includes('Ubuntu 18.04')) &&
          !osInfo.distro.toLowerCase().includes('lts')) {
        medium.push({
          name: 'Aging Linux Distribution',
          description: `${osInfo.distro} may have limited security update support.`,
          recommendation: 'Upgrade to a newer LTS version.'
        });
      } else if (osInfo.distro.includes('Ubuntu 14.04') || 
                osInfo.distro.includes('Debian 8')) {
        high.push({
          name: 'Unsupported Linux Distribution',
          description: `${osInfo.distro} is EOL and no longer receiving security updates.`,
          recommendation: 'Upgrade to a supported distribution version.'
        });
      }
      
      // Check for kernel versions with known vulnerabilities
      const kernelVersion = osInfo.kernel;
      if (kernelVersion.startsWith('3.') || kernelVersion.startsWith('2.')) {
        high.push({
          name: 'Outdated Linux Kernel',
          description: `Kernel ${kernelVersion} has known security vulnerabilities.`,
          recommendation: 'Update your system to get a newer kernel version.'
        });
      } else if (kernelVersion.startsWith('4.') && parseInt(kernelVersion.split('.')[1]) < 15) {
        medium.push({
          name: 'Aging Linux Kernel',
          description: `Kernel ${kernelVersion} may have unpatched vulnerabilities.`,
          recommendation: 'Consider updating your system to get a newer kernel.'
        });
      }
    }
    
    // Generic OS checks
    if (!osInfo.uefi) {
      low.push({
        name: 'Legacy BIOS Boot',
        description: 'The system is not using UEFI boot which provides additional security features.',
        recommendation: 'If hardware supports it, consider migrating to UEFI boot mode.'
      });
    }
  } catch (error) {
    logger.error(`OS vulnerability check failed: ${error.message}`);
  }
  
  return { high, medium, low };
}

/**
 * Check for weak security configurations
 */
async function checkWeakConfigurations() {
  const high = [];
  const medium = [];
  const low = [];
  
  try {
    if (isWindows) {
      // Windows configuration checks
      
      // Check password policy
      try {
        const { stdout } = await exec('net accounts');
        
        const maxPwdAge = stdout.match(/Maximum password age \(days\):\s+(\d+)/i);
        const minPwdLength = stdout.match(/Minimum password length:\s+(\d+)/i);
        
        if (maxPwdAge && parseInt(maxPwdAge[1]) > 90) {
          medium.push({
            name: 'Weak Password Policy - Age',
            description: `Maximum password age is set to ${maxPwdAge[1]} days, which is longer than recommended.`,
            recommendation: 'Set maximum password age to 60-90 days.'
          });
        }
        
        if (minPwdLength && parseInt(minPwdLength[1]) < 8) {
          high.push({
            name: 'Weak Password Policy - Length',
            description: `Minimum password length is set to ${minPwdLength[1]} characters, which is shorter than recommended.`,
            recommendation: 'Set minimum password length to at least 12 characters.'
          });
        }
      } catch (e) {
        logger.error(`Password policy check failed: ${e.message}`);
      }
      
      // Check for User Account Control
      try {
        const { stdout } = await exec('reg query "HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System" /v EnableLUA');
        
        if (stdout.includes('0x0')) {
          high.push({
            name: 'User Account Control Disabled',
            description: 'UAC is disabled, which allows malware to more easily gain system access.',
            recommendation: 'Enable User Account Control in Control Panel.'
          });
        }
      } catch (e) {
        logger.error(`UAC check failed: ${e.message}`);
      }
    } else if (isMac) {
      // macOS configuration checks
      
      // Check for automatic updates
      try {
        const { stdout } = await exec('defaults read /Library/Preferences/com.apple.SoftwareUpdate.plist AutomaticCheckEnabled');
        
        if (stdout.trim() === '0') {
          medium.push({
            name: 'Automatic Updates Disabled',
            description: 'The system is not set to automatically check for updates.',
            recommendation: 'Enable automatic updates in System Preferences.'
          });
        }
      } catch (e) {
        logger.error(`Automatic updates check failed: ${e.message}`);
      }
      
      // Check for firmware password
      try {
        const { stdout } = await exec('sudo firmwarepasswd -check');
        
        if (stdout.includes('No password set')) {
          low.push({
            name: 'No Firmware Password',
            description: 'No firmware password is set, allowing anyone with physical access to boot to recovery mode.',
            recommendation: 'Set a firmware password in Recovery Mode.'
          });
        }
      } catch (e) {
        // This might fail if not run as root, which is expected
        logger.debug(`Firmware password check skipped: ${e.message}`);
      }
    } else if (isLinux) {
      // Linux configuration checks
      
      // Check for weak SSH configuration
      if (await fileExists('/etc/ssh/sshd_config')) {
        try {
          const sshConfig = await fs.readFile('/etc/ssh/sshd_config', 'utf8');
          
          if (sshConfig.includes('PermitRootLogin yes')) {
            high.push({
              name: 'SSH Root Login Enabled',
              description: 'SSH configuration allows direct root login, which is a security risk.',
              recommendation: 'Disable root login by setting "PermitRootLogin no" in /etc/ssh/sshd_config'
            });
          }
          
          if (sshConfig.includes('PasswordAuthentication yes')) {
            medium.push({
              name: 'SSH Password Authentication Enabled',
              description: 'SSH allows password authentication, which is vulnerable to brute force attacks.',
              recommendation: 'Use key-based authentication by setting "PasswordAuthentication no"'
            });
          }
        } catch (e) {
          logger.error(`SSH config check failed: ${e.message}`);
        }
      }
      
      // Check for weak sudo configuration
      if (await fileExists('/etc/sudoers')) {
        try {
          const { stdout } = await exec('sudo -l');
          
          if (stdout.includes('NOPASSWD')) {
            high.push({
              name: 'Sudo Without Password',
              description: 'Some commands can be executed with sudo without providing a password.',
              recommendation: 'Review and fix sudoers configuration to require passwords.'
            });
          }
        } catch (e) {
          // This might fail if not run interactively
          logger.debug(`Sudo config check skipped: ${e.message}`);
        }
      }
    }
  } catch (error) {
    logger.error(`Weak configuration check failed: ${error.message}`);
  }
  
  return { high, medium, low };
}

/**
 * Check for outdated software with known vulnerabilities
 */
async function checkOutdatedSoftware(installedSoftware) {
  const high = [];
  const medium = [];
  const low = [];
  
  // This would ideally check against a CVE database
  // For this example, we'll check for commonly known outdated software
  
  try {
    // Check browsers
    installedSoftware.forEach(software => {
      const name = software.name.toLowerCase();
      const version = software.version;
      
      // Check Firefox
      if (name.includes('firefox') && version) {
        const majorVersion = parseInt(version.split('.')[0]);
        if (majorVersion < 78) {
          high.push({
            name: 'Outdated Firefox Browser',
            description: `Firefox version ${version} has known security vulnerabilities.`,
            recommendation: 'Update Firefox to the latest version.'
          });
        } else if (majorVersion < 90) {
          medium.push({
            name: 'Aging Firefox Browser',
            description: `Firefox version ${version} may have unpatched vulnerabilities.`,
            recommendation: 'Update Firefox to the latest version.'
          });
        }
      }
      
      // Check Chrome
      if ((name.includes('chrome') || name.includes('google chrome')) && version) {
        const majorVersion = parseInt(version.split('.')[0]);
        if (majorVersion < 80) {
          high.push({
            name: 'Outdated Chrome Browser',
            description: `Chrome version ${version} has known security vulnerabilities.`,
            recommendation: 'Update Chrome to the latest version.'
          });
        } else if (majorVersion < 90) {
          medium.push({
            name: 'Aging Chrome Browser',
            description: `Chrome version ${version} may have unpatched vulnerabilities.`,
            recommendation: 'Update Chrome to the latest version.'
          });
        }
      }
      
      // Check Java
      if (name.includes('java') && version) {
        if (version.includes('1.7') || version.includes('1.6') || version.includes('1.5')) {
          high.push({
            name: 'Outdated Java Installation',
            description: `Java version ${version} has known security vulnerabilities.`,
            recommendation: 'Update Java to the latest version or remove if not needed.'
          });
        } else if (version.includes('1.8')) {
          const updateVersion = version.split('_')[1] ? parseInt(version.split('_')[1]) : 0;
          if (updateVersion < 241) {
            medium.push({
              name: 'Outdated Java 8 Installation',
              description: `Java version ${version} may have unpatched vulnerabilities.`,
              recommendation: 'Update Java to the latest version.'
            });
          }
        }
      }
      
      // Check Adobe Reader
      if ((name.includes('adobe') && name.includes('reader')) && version) {
        const majorVersion = parseInt(version.split('.')[0]);
        if (majorVersion < 20) {
          medium.push({
            name: 'Outdated Adobe Reader',
            description: `Adobe Reader version ${version} may have unpatched vulnerabilities.`,
            recommendation: 'Update Adobe Reader to the latest version.'
          });
        }
      }
    });
  } catch (error) {
    logger.error(`Outdated software check failed: ${error.message}`);
  }
  
  return { high, medium, low };
}

/**
 * Check for insecure services
 */
function checkInsecureServices(services) {
  const high = [];
  const medium = [];
  const low = [];
  
  try {
    // Look for known vulnerable services
    services.forEach(service => {
      const name = service.name.toLowerCase();
      
      // Telnet service
      if (name.includes('telnet') && service.running) {
        high.push({
          name: 'Telnet Service Running',
          description: 'Telnet transmits data in cleartext and is vulnerable to MITM attacks.',
          recommendation: 'Disable Telnet service and use SSH instead.'
        });
      }
      
      // FTP service
      if ((name.includes('ftp') && !name.includes('sftp')) && service.running) {
        high.push({
          name: 'FTP Service Running',
          description: 'Standard FTP transmits credentials in cleartext.',
          recommendation: 'Disable FTP service and use SFTP or another secure alternative.'
        });
      }
      
      // RDP service if exposed
      if ((name.includes('remote desktop') || name.includes('rdp') || name.includes('terminal server')) && service.running) {
        medium.push({
          name: 'Remote Desktop Service Running',
          description: 'Remote Desktop service could be exposed to brute force attacks.',
          recommendation: 'Secure RDP with strong passwords, limit access, and use a VPN.'
        });
      }
      
      // Print services exposed
      if ((name.includes('print') || name.includes('spooler')) && service.running) {
        low.push({
          name: 'Print Service Running',
          description: 'Print services may contain vulnerabilities if exposed to the network.',
          recommendation: 'Disable print services if not needed or ensure they are properly secured.'
        });
      }
    });
  } catch (error) {
    logger.error(`Insecure services check failed: ${error.message}`);
  }
  
  return { high, medium, low };
}

/**
 * Additional checks for thorough scan
 */
async function thoroughChecks() {
  // This would do more intensive checks that take longer
  // For this example, we'll simulate some additional checks
  
  const vulnerabilities = {
    high: [],
    medium: [],
    low: []
  };
  
  try {
    if (isWindows) {
      // Check for WSUS misconfiguration that could allow MITM
      vulnerabilities.medium.push({
        name: 'Windows Update Configuration Check',
        description: 'Thorough check of Windows Update configuration for potential MITM vulnerabilities.',
        recommendation: 'Ensure WSUS uses HTTPS and proper certificates.'
      });
    } else if (isMac) {
      // Check for Gatekeeper bypass vulnerabilities
      vulnerabilities.medium.push({
        name: 'Gatekeeper Bypass Check',
        description: 'Advanced check for Gatekeeper bypass vulnerabilities.',
        recommendation: 'Ensure Gatekeeper is properly configured and all security updates are installed.'
      });
    } else if (isLinux) {
      // Check for Dirty COW and similar kernel vulnerabilities
      vulnerabilities.high.push({
        name: 'Kernel Vulnerability Deep Scan',
        description: 'In-depth check for kernel vulnerabilities like Dirty COW.',
        recommendation: 'Install all kernel security updates.'
      });
    }
    
    // Generic thorough checks
    vulnerabilities.low.push({
      name: 'SSL/TLS Configuration Check',
      description: 'Detailed check of SSL/TLS configurations for weak ciphers and protocols.',
      recommendation: 'Update SSL/TLS configurations to use only strong ciphers and disable older protocols.'
    });
  } catch (error) {
    logger.error(`Thorough checks failed: ${error.message}`);
  }
  
  return {
    vulnerabilities,
    vulnerabilityCounts: {
      high: vulnerabilities.high.length,
      medium: vulnerabilities.medium.length,
      low: vulnerabilities.low.length
    }
  };
}

/**
 * Check for common vulnerable ports
 */
async function checkCommonVulnerablePorts() {
  const high = [];
  const medium = [];
  const low = [];
  
  try {
    // Get network connections
    const { stdout } = await exec('netstat -tuln');
    
    // Vulnerable ports to check
    const vulnerablePorts = [
      { port: 21, service: 'FTP', severity: 'high' },
      { port: 23, service: 'Telnet', severity: 'high' },
      { port: 25, service: 'SMTP', severity: 'medium' },
      { port: 53, service: 'DNS', severity: 'medium' },
      { port: 139, service: 'NetBIOS', severity: 'high' },
      { port: 445, service: 'SMB', severity: 'high' },
      { port: 1433, service: 'MSSQL', severity: 'medium' },
      { port: 1521, service: 'Oracle', severity: 'medium' },
      { port: 3306, service: 'MySQL', severity: 'medium' },
      { port: 3389, service: 'RDP', severity: 'medium' },
      { port: 5900, service: 'VNC', severity: 'high' }
    ];
    
    // Check for each vulnerable port
    vulnerablePorts.forEach(({ port, service, severity }) => {
      const portRegex = new RegExp(`[.:](${port})\\s`);
      if (portRegex.test(stdout)) {
        const vulnerability = {
          name: `${service} Port Exposed (${port})`,
          description: `Port ${port} (${service}) is open and could be accessed by attackers.`,
          recommendation: `Close port ${port} if not needed or secure it properly.`
        };
        
        if (severity === 'high') high.push(vulnerability);
        else if (severity === 'medium') medium.push(vulnerability);
        else low.push(vulnerability);
      }
    });
  } catch (error) {
    logger.error(`Vulnerable port check failed: ${error.message}`);
  }
  
  return { high, medium, low };
}

/**
 * Check for weak encryption in network services
 */
async function checkWeakEncryption() {
  const high = [];
  const medium = [];
  const low = [];
  
  try {
    if (isWindows) {
      // Check if SSLv3 or TLS 1.0/1.1 is enabled
      try {
        const { stdout } = await exec('reg query "HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\Protocols" /s');
        
        if (stdout.includes('SSL 3.0') && !stdout.includes('DisabledByDefault    REG_DWORD    0x1')) {
          high.push({
            name: 'SSLv3 Enabled',
            description: 'SSLv3 is vulnerable to the POODLE attack and should be disabled.',
            recommendation: 'Disable SSLv3 in Windows registry.'
          });
        }
        
        if (stdout.includes('TLS 1.0') && !stdout.includes('DisabledByDefault    REG_DWORD    0x1')) {
          medium.push({
            name: 'TLS 1.0 Enabled',
            description: 'TLS 1.0 has known vulnerabilities and should be disabled.',
            recommendation: 'Disable TLS 1.0 in Windows registry.'
          });
        }
      } catch (e) {
        logger.error(`SSL/TLS registry check failed: ${e.message}`);
      }
    } else if (isMac || isLinux) {
      // Check OpenSSL version
      try {
        const { stdout } = await exec('openssl version');
        const versionMatch = stdout.match(/OpenSSL\s+(\d+\.\d+\.\d+)/);
        
        if (versionMatch) {
          const version = versionMatch[1];
          const [major, minor, patch] = version.split('.').map(v => parseInt(v));
          
          if (major === 1 && minor === 0 && patch < 2) {
            high.push({
              name: 'Vulnerable OpenSSL Version',
              description: `OpenSSL ${version} is vulnerable to Heartbleed.`,
              recommendation: 'Update OpenSSL to the latest version.'
            });
          } else if (major === 1 && minor === 0 && patch < 1) {
            medium.push({
              name: 'Outdated OpenSSL Version',
              description: `OpenSSL ${version} has known vulnerabilities.`,
              recommendation: 'Update OpenSSL to the latest version.'
            });
          }
        }
      } catch (e) {
        logger.error(`OpenSSL version check failed: ${e.message}`);
      }
    }
    
    // Check for SSH weak keys
    if (!isWindows && await fileExists('/etc/ssh/ssh_host_key')) {
      medium.push({
        name: 'SSH Using Old Key Format',
        description: 'The system is using an old SSH key format that may be insecure.',
        recommendation: 'Regenerate SSH host keys using modern algorithms.'
      });
    }
  } catch (error) {
    logger.error(`Weak encryption check failed: ${error.message}`);
  }
  
  return { high, medium, low };
}

/**
 * Check for default credentials
 */
async function checkDefaultCredentials() {
  const high = [];
  const medium = [];
  const low = [];
  
  try {
    // This would need to actually try default credentials, which we won't do
    // Instead, we'll check for common default credential scenarios
    
    if (isWindows) {
      // Check for Administrator account status
      try {
        const { stdout } = await exec('net user Administrator | findstr /i "Account active"');
        if (stdout.toLowerCase().includes('account active') && stdout.toLowerCase().includes('yes')) {
          medium.push({
            name: 'Default Administrator Account Enabled',
            description: 'The default Administrator account is enabled and may be targeted for attacks.',
            recommendation: 'Rename or disable the default Administrator account.'
          });
        }
      } catch (e) {
        logger.error(`Administrator check failed: ${e.message}`);
      }
    } else if (isLinux) {
      // Check if root has no password set
      try {
        const { stdout } = await exec('grep "^root:" /etc/shadow | cut -d: -f2');
        if (stdout.trim() === '') {
          high.push({
            name: 'Root Account Has No Password',
            description: 'The root account has no password set, which is a critical security risk.',
            recommendation: 'Set a strong password for the root account immediately.'
          });
        }
      } catch (e) {
        logger.error(`Root password check failed: ${e.message}`);
      }
    }
  } catch (error) {
    logger.error(`Default credentials check failed: ${error.message}`);
  }
  
  return { high, medium, low };
}

/**
 * Additional network checks for thorough scan
 */
async function thoroughNetworkChecks() {
  const vulnerabilities = {
    high: [],
    medium: [],
    low: []
  };
  
  try {
    // Additional in-depth checks for the network
    
    // MITM vulnerability check
    vulnerabilities.high.push({
      name: 'ARP Spoofing Detection',
      description: 'Thorough check for signs of ARP spoofing or poisoning on the network.',
      recommendation: 'Implement static ARP entries for critical systems or use ARP monitoring tools.'
    });
    
    // Wi-Fi security check if applicable
    if (!isWindows) {
      try {
        const { stdout } = await exec('iwconfig 2>/dev/null || /System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -I');
        if (stdout.includes('WEP')) {
          vulnerabilities.high.push({
            name: 'Insecure Wi-Fi Encryption',
            description: 'The system is connected to a Wi-Fi network using insecure WEP encryption.',
            recommendation: 'Connect to networks that use WPA2 or WPA3 encryption.'
          });
        } else if (stdout.includes('WPA') && !stdout.includes('WPA2') && !stdout.includes('WPA3')) {
          vulnerabilities.medium.push({
            name: 'Legacy Wi-Fi Encryption',
            description: 'The system is connected to a Wi-Fi network using legacy WPA encryption.',
            recommendation: 'Connect to networks that use WPA2 or WPA3 encryption.'
          });
        }
      } catch (e) {
        logger.error(`Wi-Fi security check failed: ${e.message}`);
      }
    }
  } catch (error) {
    logger.error(`Thorough network checks failed: ${error.message}`);
  }
  
  return {
    vulnerabilities,
    vulnerabilityCounts: {
      high: vulnerabilities.high.length,
      medium: vulnerabilities.medium.length,
      low: vulnerabilities.low.length
    }
  };
}

/**
 * Generate recommendations based on findings
 */
function generateRecommendations(osVulns, weakConfigs, outdatedSoftware, insecureServices) {
  const recommendations = [];
  
  // Prioritize high severity issues first
  const highIssues = [
    ...osVulns.high,
    ...weakConfigs.high,
    ...outdatedSoftware.high,
    ...insecureServices.high
  ];
  
  const mediumIssues = [
    ...osVulns.medium,
    ...weakConfigs.medium,
    ...outdatedSoftware.medium,
    ...insecureServices.medium
  ];
  
  const lowIssues = [
    ...osVulns.low,
    ...weakConfigs.low,
    ...outdatedSoftware.low,
    ...insecureServices.low
  ];
  
  // Add high priority recommendations
  highIssues.forEach(issue => {
    if (issue.recommendation) {
      recommendations.push({
        priority: 'high',
        recommendation: issue.recommendation,
        issue: issue.name
      });
    }
  });
  
  // Add medium priority recommendations
  mediumIssues.forEach(issue => {
    if (issue.recommendation) {
      recommendations.push({
        priority: 'medium',
        recommendation: issue.recommendation,
        issue: issue.name
      });
    }
  });
  
  // Add low priority recommendations
  lowIssues.forEach(issue => {
    if (issue.recommendation) {
      recommendations.push({
        priority: 'low',
        recommendation: issue.recommendation,
        issue: issue.name
      });
    }
  });
  
  return recommendations;
}

/**
 * Generate network security recommendations
 */
function generateNetworkRecommendations(openPorts, weakEncryption, defaultCreds) {
  const recommendations = [];
  
  // Prioritize high severity issues first
  const highIssues = [
    ...openPorts.high,
    ...weakEncryption.high,
    ...defaultCreds.high
  ];
  
  const mediumIssues = [
    ...openPorts.medium,
    ...weakEncryption.medium,
    ...defaultCreds.medium
  ];
  
  const lowIssues = [
    ...openPorts.low,
    ...weakEncryption.low,
    ...defaultCreds.low
  ];
  
  // Add high priority recommendations
  highIssues.forEach(issue => {
    if (issue.recommendation) {
      recommendations.push({
        priority: 'high',
        recommendation: issue.recommendation,
        issue: issue.name
      });
    }
  });
  
  // Add medium priority recommendations
  mediumIssues.forEach(issue => {
    if (issue.recommendation) {
      recommendations.push({
        priority: 'medium',
        recommendation: issue.recommendation,
        issue: issue.name
      });
    }
  });
  
  // Add low priority recommendations
  lowIssues.forEach(issue => {
    if (issue.recommendation) {
      recommendations.push({
        priority: 'low',
        recommendation: issue.recommendation,
        issue: issue.name
      });
    }
  });
  
  return recommendations;
}

module.exports = {
  scanLocalSystem,
  scanNetwork
};